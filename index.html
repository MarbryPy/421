<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>421 â€“ Multi (Firebase)</title>
<style>
  :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --fg:#e5e7eb; --accent:#22d3ee; --btn:#1f2937; --warn:#f59e0b; --bad:#ef4444; }
  * { box-sizing: border-box; } body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; gap:12px; }
  h1 { margin:0; font-size:18px; letter-spacing:.3px; }
  main { max-width:1100px; margin:0 auto; padding:20px; display:grid; gap:16px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  .card { background:var(--panel); border:1px solid #1f2937; border-radius:14px; padding:14px; }
  .card h2 { margin:0 0 8px 0; font-size:15px; color:var(--accent); }
  .muted { color:var(--muted); }
  input { background:#0b1220; color:#e5e7eb; border:1px solid #1f2937; border-radius:10px; padding:10px 12px; }
  button { appearance:none; border:1px solid #283548; background:var(--btn); color:var(--fg); padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
  button.primary { border-color:#164e63; background:#0e749022; }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .players { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; }
  .player { position:relative; transition: box-shadow .2s ease; }
  .player.active { outline:2px solid var(--accent); outline-offset:2px; box-shadow:0 0 0 0 rgba(34,211,238,.6); animation:pulse 1.6s infinite; }
  @keyframes pulse { 0%{ box-shadow:0 0 0 0 rgba(34,211,238,.6);} 70%{ box-shadow:0 0 0 12px rgba(34,211,238,0);} 100%{ box-shadow:0 0 0 0 rgba(34,211,238,0);} }
  .pill { position:absolute; top:10px; right:10px; font-size:12px; color:#0e7490; background:#0e749022; border:1px solid #0e749022; padding:2px 8px; border-radius:999px; }
  .dice { display:flex; gap:10px; } .die { width:70px; height:70px; border-radius:10px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; position:relative; }
  .die span { font-size:28px; font-weight:800; } .die small { position:absolute; bottom:6px; left:6px; font-size:10px; color:var(--muted); }
  .die.roll { outline:2px solid var(--warn); outline-offset:2px; }
  .mini { display:flex; gap:4px; margin-top:6px; }
  .mini .d { width:18px; height:18px; border-radius:4px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; font-size:11px; }
  .log { max-height:260px; overflow:auto; border-radius:10px; background:#0b1220; border:1px solid #1f2937; padding:10px; font-size:13px; }
  .log p { margin:0 0 8px 0; }
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; padding:20px; }
  .dialog { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; max-width:420px; width:90%; text-align:center; }
</style>
</head>
<body>
<header>
  <h1>ðŸŽ² 421 â€“ Multi (Firebase)</h1>
  <div class="small">Aucun compte requis</div>
</header>

<main>
  <section id="lobby" class="card">
    <h2>CrÃ©er / Rejoindre la salle</h2>
    <div class="row">
      <input id="displayName" placeholder="Ton pseudo" />
      <input id="roomInput" placeholder="Code (ex: 5L9QK)" />
      <input id="startPoints" type="number" min="1" max="99" value="10" style="width:90px" title="Points de dÃ©part"/>
      <button id="createBtn" class="primary">CrÃ©er</button>
      <button id="joinBtn">Rejoindre</button>
    </div>
    <div class="small">Le crÃ©ateur dÃ©marre quand tout le monde est lÃ  (min 2 joueurs).</div>
  </section>

  <section id="game" class="card" style="display:none;">
    <h2>Partie</h2>
    <div class="row" style="justify-content:space-between; align-items:start;">
      <div>
        <div class="muted">Salle</div>
        <div id="roomCode" class="small">â€”</div>
        <div id="interBanner" class="small" style="margin-top:6px;"></div>
        <div class="muted" style="margin-top:6px;">Joueur actuel</div>
        <div id="currentPlayer" style="font-size:22px;font-weight:800;">â€”</div>
        <div class="muted" style="margin-top:6px;">Lancers restants : <span id="rollsLeft">â€”</span></div>
      </div>
      <div>
        <div class="muted">Ta main</div>
        <div id="dice" class="dice"></div>
        <div id="comboHint" class="small">â€”</div>
      </div>
      <div class="row" style="flex-direction:column; min-width:220px;">
        <button id="rollBtn" class="primary">Relancer (sÃ©lectionnÃ©s)</button>
        <button id="toggleAllBtn">Tout sÃ©lectionner / dÃ©sÃ©lectionner</button>
        <button id="endTurnBtn">Terminer mon tour</button>
        <button id="startBtn" class="primary">DÃ©marrer la partie</button>
        <button id="leaveBtn">Quitter</button>
      </div>
    </div>
  </section>

  <!-- Dynamic players grid -->
  <section id="players" class="players" style="display:none;"></section>

  <section id="logCard" class="card" style="display:none;">
    <h2>Historique</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<div id="overlay" class="overlay">
  <div class="dialog">
    <div style="font-size:22px; font-weight:800;">ðŸŽ‰ Vainqueur</div>
    <div id="winnerName" style="margin:8px 0 12px;">â€”</div>
    <button id="replayBtn" class="primary">Rejouer (mÃªmes joueurs)</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getDatabase, ref, onValue, set, update, get, runTransaction, push } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

  const cfg = {"apiKey": "AIzaSyB9QKf88f8YS3b8hQ_hbJC4rwre9UYNIUI", "authDomain": "mon421-a1108.firebaseapp.com", "databaseURL": "https://mon421-a1108-default-rtdb.europe-west1.firebasedatabase.app", "projectId": "mon421-a1108", "storageBucket": "mon421-a1108.appspot.com", "messagingSenderId": "354289081138", "appId": "1:354289081138:web:be104504732e1ef984952b"};
  const app = initializeApp(cfg);
  const db = getDatabase(app);
  const $ = s => document.querySelector(s);

  /* === DOM cache === */
  const el = {
    lobby: $('#lobby'), game: $('#game'), players: $('#players'), logCard: $('#logCard'),
    displayName: $('#displayName'), roomInput: $('#roomInput'), startPoints: $('#startPoints'),
    createBtn: $('#createBtn'), joinBtn: $('#joinBtn'), startBtn: $('#startBtn'), leaveBtn: $('#leaveBtn'),
    roomCode: $('#roomCode'), interBanner: $('#interBanner'),
    currentPlayer: $('#currentPlayer'), rollsLeft: $('#rollsLeft'),
    dice: $('#dice'), comboHint: $('#comboHint'), rollBtn: $('#rollBtn'), toggleAllBtn: $('#toggleAllBtn'), endTurnBtn: $('#endTurnBtn'),
    log: $('#log'), overlay: $('#overlay'), winnerName: $('#winnerName'), replayBtn: $('#replayBtn')
  };

  // ---- Persistence
  let roomId = localStorage.getItem('r421_roomId') || null;
  let myId   = localStorage.getItem('r421_myId') || (Math.random().toString(36).slice(2,10));
  localStorage.setItem('r421_myId', myId);
  let seat   = localStorage.getItem('r421_seat');
  if (seat !== null) seat = parseInt(seat,10); else seat = null;

  function safePath(patches) {
    if (!roomId) return null;
    const out = {};
    for (const k in patches) out[`rooms/${roomId}/${k}`] = patches[k];
    return out;
  }
  async function safeUpdate(patches) { if (!roomId) return; await update(ref(db), safePath(patches)); }
  async function appendLog(msg){ if (!roomId) return; try { await push(ref(db, `rooms/${roomId}/log`), { t: Date.now(), msg }); } catch(e){} }

  // ---- Sounds (minimal)
  const AC = window.AudioContext||window.webkitAudioContext; const ctx = new AC();
  function tone(f,d=0.12,t='sine',v=0.05){try{const o=ctx.createOscillator(),g=ctx.createGain();o.type=t;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(ctx.destination);o.start();setTimeout(()=>o.stop(),d*1000);}catch(e){}}
  function yourTurnSound(){ tone(880); setTimeout(()=>tone(1175),120); }

  // ---- Rules
  const sortAsc=a=>[...a].sort((x,y)=>x-y), sortDesc=a=>[...a].sort((x,y)=>y-x);
  const is421 = d => (sortDesc(d)[0]===4 && sortDesc(d)[1]===2 && sortDesc(d)[2]===1);
  const isBrelan = d => d[0]===d[1] && d[1]===d[2];
  const is111 = d => d[0]===1 && d[1]===1 && d[2]===1;
  const is11x = d => sortDesc(d)[0]!==1 && ((d[0]===1 && d[1]===1) || (d[0]===1 && d[2]===1) || (d[1]===1 && d[2]===1));
  const xOfPair = d => { const c={}; d.forEach(v=>c[v]=(c[v]||0)+1); for(const k in c) if(c[k]===1) return parseInt(k,10); return null; };
  const isSuite = d => ['123','234','345','456'].includes(sortAsc(d).join(''));
  const isPaire = d => new Set(d).size===2;
  function rankHand(d){
    const s=sortDesc(d);
    if(is421(s)) return {order:7, label:'421', category:'421', meta:{}};
    if(is111(s)) return {order:6, label:'1-1-1', category:'111', meta:{}};
    if(is11x(s)) return {order:5, label:`1-1-${xOfPair(s)}`, category:'11x', meta:{x:xOfPair(s)}};
    if(isBrelan(s)) return {order:4, label:`${s[0]}-${s[0]}-${s[0]}`, category:'Brelan', meta:{x:s[0]}};
    if(isSuite(s)) return {order:3, label:sortAsc(s).join('-'), category:'Suite', meta:{}};
    if(isPaire(s)) { let pair,k; if(s[0]===s[1]){pair=s[0];k=s[2];} else {pair=s[1];k=s[0];} return {order:2, label:`${pair}-${pair}-${k}`, category:'Paire', meta:{pair,k}}; }
    return {order:1, label:`${s[0]}-${s[1]}-${s[2]}`, category:'Haute', meta:{}};
  }
  function winnerPoints(rank){
    switch(rank.category){
      case '421': return 8;
      case '111': return 7;
      case '11x': return rank.meta?.x || 0;
      case 'Brelan': return rank.meta?.x || 0;
      case 'Suite': return 2;
      case 'Paire': return 1;
      case 'Haute': return 1;
      default: return 0;
    }
  }

  // ---- Dynamic seats helpers
  const seatKeys = room => Object.keys(room.players||{})
    .map(k=>parseInt(k,10))
    .filter(n=>!Number.isNaN(n))
    .sort((a,b)=>a-b);
  const joinedSeats = room => seatKeys(room).filter(i=>room.players[i]?.id);

  function setMiniDice(container, dice){
    container.innerHTML='';
    (dice||[1,1,1]).forEach(v=>{
      const d=document.createElement('div'); d.className='d'; d.textContent=v; container.appendChild(d);
    });
  }

  // ---- Lobby actions
  async function createRoom(){
    const code=($('#roomInput').value.trim()||Math.random().toString(36).slice(2,7)).toUpperCase();
    const startPts = Math.max(1, Math.min(99, parseInt($('#startPoints').value||'10',10)));
    const init={ createdAt:Date.now(), started:false, locked:false, gameOver:false, startPoints:startPts,
      current:0, round:1, firstRollsLimit:null, players:{}, log:[] };
    await set(ref(db,'rooms/'+code), init);
    roomId=code; localStorage.setItem('r421_roomId', roomId);
    await joinRoom(code);
  }

  async function joinRoom(code){
    code=(code||$('#roomInput').value.trim()).toUpperCase();
    if(!code) return alert('Code manquant');
    const snap=await get(ref(db,'rooms/'+code));
    if(!snap.exists()) return alert('Salle introuvable.');
    const room=snap.val();
    // refuse new joins after start (unless rejoin same seat)
    if(room.started && room.locked){
      let already=false;
      for(const s of seatKeys(room)) if(room.players[s]?.id===myId) { already=true; break; }
      if(!already) return alert('Partie en cours â€” rejoins avant le dÃ©marrage.');
    }

    // rejoin if already seated
    seat=null;
    for(const s of seatKeys(room)){ if(room.players[s]?.id===myId){ seat=s; break; } }

    // claim lowest free seat if not started
    if(seat===null && !room.started){
      let seatIdx=0; const taken=new Set(seatKeys(room));
      while(taken.has(seatIdx)) seatIdx++;
      const path = `rooms/${code}/players/${seatIdx}`;
      const res = await runTransaction(ref(db, path), (cur)=>{
        if(!cur || !cur.id) return {
          id: myId, name: ($('#displayName').value.trim()||'Joueur'),
          score: room.startPoints||10, dice:[1,1,1], roll:[true,true,true],
          rollsLeft:3, done:false, lastRank:null, rollsUsed:0
        };
        return cur;
      });
      if(res.committed && res.snapshot.val()?.id===myId){ seat=seatIdx; }
      if(seat!==null) await appendLog(`ðŸŸ¢ ${($('#displayName').value.trim()||'Joueur')} a rejoint (J${seat+1})`);
    }

    roomId=code; localStorage.setItem('r421_roomId', roomId);
    if(seat!==null) localStorage.setItem('r421_seat', String(seat));
    el.lobby.style.display='none'; el.game.style.display='block'; el.players.style.display='grid'; el.logCard.style.display='block'; el.roomCode.textContent=code;
    subscribe();
  }

  el.createBtn.addEventListener('click', async()=>{ try{ await createRoom(); } catch(e){ alert('Erreur crÃ©ation: '+(e&&e.message||e)); console.error(e); }});
  el.joinBtn.addEventListener('click', async()=>{ try{ await joinRoom($('#roomInput').value); } catch(e){ alert('Erreur rejoindre: '+(e&&e.message||e)); console.error(e); }});
  el.leaveBtn.addEventListener('click', ()=>location.reload());

  // ---- Subscription
  let lastRoom = null, watchdogBusy = false;
  function subscribe(){
    onValue(ref(db,'rooms/'+roomId), (snap)=>{
      if(!snap.exists()) return;
      lastRoom = snap.val();
      render(lastRoom);
    });
    // extra watchdog every 1.2s (belt & suspenders)
    setInterval(async()=>{
      if (watchdogBusy || !lastRoom) return;
      const seats = joinedSeats(lastRoom);
      const allDone = lastRoom.started && !lastRoom.gameOver && seats.length>0 && seats.every(i=>lastRoom.players[i].done);
      if (allDone) {
        watchdogBusy = true;
        try{ await settleTransaction(); } finally { watchdogBusy = false; }
      }
    }, 1200);
  }

  function renderPlayers(room){
    const cont = el.players;
    cont.innerHTML = '';
    seatKeys(room).forEach(i=>{
      const p = room.players[i] || {};
      const card = document.createElement('div');
      card.className = 'card player' + (room.started && room.current===i && p.id && !p.done ? ' active' : '');
      card.innerHTML = `
        <div class="pill">J${i+1}</div>
        <h2>${p.id ? (p.name||('Joueur '+(i+1))) : 'â€” (vide)'}</h2>
        <div class="small"><span>${p.score ?? 'â€”'}</span> pts</div>
        <div class="small">${p.lastRank ? (p.lastRank.label+' ('+p.lastRank.category+')') : 'â€”'}</div>
        <div class="mini" id="m${i}"></div>
      `;
      cont.appendChild(card);
      setMiniDice(card.querySelector('#m'+i), p.dice);
    });
  }

  function render(room){
    // log
    el.log.innerHTML='';
    const entries = room.log ? Object.values(room.log).sort((a,b)=>a.t-b.t) : [];
    entries.forEach(e=>{ const p=document.createElement('p'); p.textContent=e.msg; el.log.appendChild(p); });

    // players grid
    renderPlayers(room);

    // lobby/banner
    const seats = joinedSeats(room);
    el.startBtn.disabled = room.started || seats.length < 2;
    el.interBanner.textContent = room.started ? '' : `Joueurs prÃªts: ${seats.length} (min 2)`;

    // current/me
    const me = (seat!=null && room.players[seat]) ? room.players[seat] : null;
    const myTurn = !!(me && room.started && room.current===seat && !me.done);
    el.currentPlayer.textContent = room.players[room.current]?.name || 'â€”';
    el.rollsLeft.textContent = me ? (me.rollsLeft ?? 'â€”') : 'â€”';

    // winner overlay
    if(room.gameOver){
      el.overlay.style.display='flex';
      const w = room.winnerSeat!=null ? (room.players[room.winnerSeat]?.name || 'â€”') : 'â€”';
      el.winnerName.textContent = w;
    } else {
      el.overlay.style.display='none';
    }

    // dice UI (mine)
    el.dice.innerHTML='';
    const dice = me ? (me.dice||[1,1,1]) : [1,1,1];
    const firstRoll = me ? (me.rollsLeft===3) : false;
    dice.forEach((v,i)=>{
      const b=document.createElement('button');
      b.className='die'+((me && me.roll && me.roll[i])?' roll':'');
      b.innerHTML=`<span>${v}</span><small>${(me && me.roll && me.roll[i])?'Ã  relancer':'gardÃ©'}</small>`;
      b.onclick=()=>{ if(firstRoll) return; toggleRoll(i); };
      el.dice.appendChild(b);
    });
    if(firstRoll && me) safeUpdate({ ['players/'+seat+'/roll']:[true,true,true] });

    // roll limit enforcement
    const limit = room.firstRollsLimit;
    const disableRoll = !myTurn || (me && me.rollsLeft<=0) || (limit!=null && (3-me.rollsLeft) >= limit);
    el.toggleAllBtn.disabled = firstRoll || !myTurn;
    el.rollBtn.disabled = disableRoll;
    el.endTurnBtn.disabled = !myTurn;

    if(myTurn) yourTurnSound();

    // ðŸ”§ WATCHDOG: if all joined players are done -> settle
    const allDone = seats.length>0 && seats.every(i => room.players[i].done);
    if (room.started && !room.gameOver && allDone) {
      if (!render._settleScheduled) {
        render._settleScheduled = true;
        setTimeout(async () => {
          try { await settleTransaction(); }
          finally { render._settleScheduled = false; }
        }, 150);
      }
    }
  }

  async function toggleRoll(i){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done) return;
    if(me.rollsLeft===3) return;
    const roll=me.roll.slice(); roll[i]=!roll[i];
    await safeUpdate({ ['players/'+seat+'/roll']: roll });
  }

  async function startGame(){
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    const seats=joinedSeats(room);
    if(seats.length<2) return alert('Il faut au moins 2 joueurs.');
    const updates={};
    seats.forEach(i=>{
      const p=room.players[i];
      updates['players/'+i] = { ...p, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 };
    });
    updates['current'] = seats[0]; // starter = first seat
    updates['round'] = 1;
    updates['started'] = true;
    updates['locked'] = true; // freeze seats
    updates['gameOver'] = false;
    updates['firstRollsLimit'] = null;
    await safeUpdate(updates);
    await appendLog(`ðŸš€ Partie dÃ©marrÃ©e (joueurs: ${seats.length})`);
  }
  el.startBtn.addEventListener('click', startGame);

  async function rollSelected(){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done || me.rollsLeft<=0) return;
    // enforce round limit
    const limit = room.firstRollsLimit;
    const used = 3 - me.rollsLeft;
    if (limit!=null && used >= limit) return;
    // animate then commit
    const dice=me.dice.slice();
    const toRoll=me.roll.map((x,idx)=>x?idx:null).filter(x=>x!==null);
    const final={}; toRoll.forEach(i=>final[i]= (1+Math.floor(Math.random()*6)));
    for(const i of toRoll){
      const steps = 10 + Math.floor(Math.random()*6);
      for(let t=0;t<steps;t++){ dice[i] = 1+Math.floor(Math.random()*6); const btn = el.dice.children[i]; if(btn) btn.querySelector('span').textContent = dice[i]; await new Promise(r=>setTimeout(r, 40)); }
      dice[i] = final[i]; const btn = el.dice.children[i]; if(btn) btn.querySelector('span').textContent = dice[i]; await new Promise(r=>setTimeout(r, 100));
    }
    const r=rankHand(dice);
    await safeUpdate({
      ['players/'+seat+'/dice']:dice,
      ['players/'+seat+'/lastRank']:r,
      ['players/'+seat+'/rollsLeft']:me.rollsLeft-1,
      ['players/'+seat+'/rollsUsed']:(me.rollsUsed||0)+1
    });
  }
  el.rollBtn.addEventListener('click', rollSelected);

  async function endTurn(){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId')); let room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done) return;
    if(me.rollsLeft===3) await rollSelected();
    const me2 = (await get(ref(db,'rooms/'+roomId+'/players/'+seat))).val();
    if(!me2.lastRank){ const r=rankHand(me2.dice); await safeUpdate({ ['players/'+seat+'/lastRank']: r }); }
    await safeUpdate({ ['players/'+seat+'/done']:true, ['players/'+seat+'/roll']:[false,false,false] });
    // if first player ends, set round roll limit and log it
    const used = me2.rollsUsed || (3 - me2.rollsLeft);
    const limit = room.firstRollsLimit;
    if(limit==null){ await safeUpdate({ firstRollsLimit: used }); await appendLog(`ðŸŽ¯ Limite de lancers ce tour: ${used} (par ${me2.name||'Joueur'})`); }
    // advance or settle
    room = (await get(ref(db,'rooms/'+roomId))).val();
    const seats=joinedSeats(room);
    const remaining = seats.filter(i=>!room.players[i].done);
    if(remaining.length>0){
      const idx = seats.indexOf(room.current); let next = room.current;
      for(let k=1;k<=seats.length;k++){ next = seats[(idx+k)%seats.length]; if(!room.players[next].done) break; }
      await safeUpdate({ current: next });
    } else {
      await settleTransaction();
    }
  }
  el.endTurnBtn.addEventListener('click', endTurn);

  async function settleTransaction(){
    if (!roomId) return;
    await runTransaction(ref(db,'rooms/'+roomId), (room)=>{
      if(!room) return room;
      const seats = joinedSeats(room);
      if(seats.length<2) return room;

      const rankOf = (i)=> (room.players[i].lastRank || rankHand(room.players[i].dice));
      const ranked = seats.map(i=>({i, r:rankOf(i)})).sort((a,b)=>a.r.order-b.r.order).reverse();

      const top = ranked[0].r.order;
      const bot = ranked[ranked.length-1].r.order;
      const bestSeats  = ranked.filter(x=>x.r.order===top).map(x=>x.i);
      const worstSeats = ranked.filter(x=>x.r.order===bot).map(x=>x.i);

      const bestSeat  = bestSeats[0];
      const worstSeat = worstSeats[0];
      const winnerRank = rankOf(bestSeat);
      const amount = winnerPoints(winnerRank);

      // winner pays loser, toward 0
      if(amount>0 && bestSeat!=null && worstSeat!=null){
        const before = room.players[bestSeat].score|0;
        const paid = Math.min(before, amount);
        room.players[bestSeat].score = before - paid;
        room.players[worstSeat].score = (room.players[worstSeat].score||0) + paid;
        room.lastTransfer = { payer: bestSeat, payee: worstSeat, amount: paid, combo: winnerRank.label };
      }

      // victory?
      let winnerSeat=null;
      for(const i of seats) if((room.players[i].score|0)===0) { winnerSeat=i; break; }
      if(winnerSeat!=null){
        room.started=false; room.gameOver=true; room.winnerSeat=winnerSeat;
        room.lastSettle = Date.now();
        return room;
      }

      // next round: loser starts; reset all joined players
      const nextStarter = worstSeats[0];
      room.round = (room.round||1)+1;
      room.current = nextStarter;
      room.firstRollsLimit = null;
      seats.forEach(i=>{
        const p=room.players[i];
        room.players[i] = { ...p, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 };
      });

      room.lastSettle = Date.now();
      return room;
    });

    // append transfer log
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    if(room.lastTransfer){
      const p=room.players[room.lastTransfer.payer]?.name||'Joueur';
      const q=room.players[room.lastTransfer.payee]?.name||'Joueur';
      await appendLog(`âœ… ${p} paie ${room.lastTransfer.amount} â†’ ${q} (${room.lastTransfer.combo})`);
      await safeUpdate({ lastTransfer: null });
    }
  }

  el.replayBtn.addEventListener('click', async ()=>{
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    const seats=joinedSeats(room);
    const upd={};
    seats.forEach(i=>{
      const base=room.startPoints||10; const p=room.players[i];
      upd['players/'+i]={...p, score:base, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0};
    });
    upd['gameOver']=false; upd['winnerSeat']=null; upd['started']=false; upd['firstRollsLimit']=null;
    await safeUpdate(upd);
  });
</script>
</body>
</html>

