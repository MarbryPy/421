Here‚Äôs a cleaned, drop-in replacement for your index.html that implements ‚Äúbest hand pays, first to zero wins,‚Äù fixes dupes, adds CSPRNG dice, deterministic tie-breaks, guards first-roll spam, debounces settle with a settling flag, and hardens the roll UI.

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>421 ‚Äì Multi (Firebase, DEBUG)</title>
<style>
  :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --fg:#e5e7eb; --accent:#22d3ee; --btn:#1f2937; --warn:#f59e0b; --bad:#ef4444; }
  * { box-sizing: border-box; } body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; gap:12px; }
  h1 { margin:0; font-size:18px; letter-spacing:.3px; }
  main { max-width:1100px; margin:0 auto; padding:20px; display:grid; gap:16px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  .card { background:var(--panel); border:1px solid #1f2937; border-radius:14px; padding:14px; }
  .card h2 { margin:0 0 8px 0; font-size:15px; color:var(--accent); }
  .muted { color:var(--muted); }
  input { background:#0b1220; color:#e5e7eb; border:1px solid #1f2937; border-radius:10px; padding:10px 12px; }
  button { appearance:none; border:1px solid #283548; background:var(--btn); color:var(--fg); padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
  button.primary { border-color:#164e63; background:#0e749022; }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .players { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; }
  .player { position:relative; transition: box-shadow .2s ease; }
  .player.active { outline:2px solid var(--accent); outline-offset:2px; box-shadow:0 0 0 0 rgba(34,211,238,.6); animation:pulse 1.6s infinite; }
  @keyframes pulse { 0%{ box-shadow:0 0 0 0 rgba(34,211,238,.6);} 70%{ box-shadow:0 0 0 12px rgba(34,211,238,0);} 100%{ box-shadow:0 0 0 0 rgba(34,211,238,0);} }
  .pill { position:absolute; top:10px; right:10px; font-size:12px; color:#0e7490; background:#0e749022; border:1px solid #0e749022; padding:2px 8px; border-radius:999px; }
  .dice { display:flex; gap:10px; }
  .die { width:70px; height:70px; border-radius:10px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; position:relative; }
  .die span { font-size:28px; font-weight:800; }
  .die small { position:absolute; bottom:6px; left:6px; font-size:10px; color:var(--muted); }
  .die.roll { outline:2px solid var(--warn); outline-offset:2px; }
  .mini { display:flex; gap:4px; margin-top:6px; }
  .mini .d { width:18px; height:18px; border-radius:4px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; font-size:11px; }
  .log { max-height:260px; overflow:auto; border-radius:10px; background:#0b1220; border:1px solid #1f2937; padding:10px; font-size:13px; }
  .log p { margin:0 0 8px 0; }
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; padding:20px; }
  .dialog { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; max-width:420px; width:90%; text-align:center; }
  .toast { position:fixed; left:50%; transform:translateX(-50%); bottom:16px; background:#0b1220; border:1px solid #f43f5e55; color:#fecaca; padding:10px 14px; border-radius:10px; display:none; z-index:999; }
  /* debug panel */
  #dbgPanel { position:fixed; left:8px; right:8px; bottom:10px; max-height:40vh; overflow:auto; background:#0b1220; border:1px solid #334155; border-radius:10px; font:12px/1.3 system-ui; padding:8px; z-index:9999; color:#e5e7eb }
  #dbgPanel pre{white-space:pre-wrap;margin:0;overflow-wrap:anywhere}
  #dbgPanel button{background:#111827;border:1px solid #334155;border-radius:8px;padding:4px 8px;color:#e5e7eb}
  .rolling { pointer-events:none; }
</style>
</head>
<body>
<header>
  <h1>üé≤ 421 ‚Äì Multi (Firebase, DEBUG)</h1>
  <div class="small">Aucun compte requis</div>
</header>

<main>
  <section id="lobby" class="card">
    <h2>Cr√©er / Rejoindre la salle</h2>
    <div class="row">
      <input id="displayName" placeholder="Ton pseudo" />
      <input id="roomInput" placeholder="Code (ex: 5L9QK)" />
      <input id="startPoints" type="number" min="1" max="99" value="10" style="width:90px" title="Points de d√©part"/>
      <button id="createBtn" class="primary">Cr√©er</button>
      <button id="joinBtn">Rejoindre</button>
    </div>
    <div class="small">Le cr√©ateur d√©marre quand tout le monde est l√† (min 2 joueurs).</div>
  </section>

  <section id="game" class="card" style="display:none;">
    <h2>Partie</h2>
    <div class="row" style="justify-content:space-between; align-items:start;">
      <div>
        <div class="muted">Salle</div>
        <div id="roomCode" class="small">‚Äî</div>
        <div id="interBanner" class="small" style="margin-top:6px;"></div>
        <div class="muted" style="margin-top:6px;">Joueur actuel</div>
        <div id="currentPlayer" style="font-size:22px;font-weight:800;">‚Äî</div>
        <div class="muted" style="margin-top:6px;">Lancers restants : <span id="rollsLeft">‚Äî</span></div>
      </div>
      <div>
        <div class="muted">Ta main</div>
        <div id="dice" class="dice"></div>
        <div id="comboHint" class="small">‚Äî</div>
      </div>
      <div class="row" style="flex-direction:column; min-width:220px;">
        <button id="rollBtn" class="primary">Relancer (s√©lectionn√©s)</button>
        <button id="toggleAllBtn">Tout s√©lectionner / d√©s√©lectionner</button>
        <button id="endTurnBtn">Terminer mon tour</button>
        <button id="startBtn" class="primary">D√©marrer la partie</button>
        <button id="leaveBtn">Quitter</button>
      </div>
    </div>
  </section>

  <section id="players" class="players" style="display:none;"></section>

  <section id="logCard" class="card" style="display:none;">
    <h2>Historique</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<div id="overlay" class="overlay">
  <div class="dialog">
    <div style="font-size:22px; font-weight:800;">üéâ Vainqueur</div>
    <div id="winnerName" style="margin:8px 0 12px;">‚Äî</div>
    <button id="replayBtn" class="primary">Rejouer (m√™mes joueurs)</button>
  </div>
</div>
<div id="toast" class="toast"></div>
<div id="dbgPanel">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
    <strong style="font-size:12px;">üîß Debug</strong>
    <button id="dbgClear" style="margin-left:auto;">Clear</button>
    <button id="dbgCollapse">Collapse</button>
  </div>
  <pre id="dbgLog"></pre>
</div>

<!-- Firebase compat (NO modules) -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js"></script>

<script>
/* ===== Firebase init (compat) ===== */
const cfg = {
  apiKey:"AIzaSyB9QKf88f8YS3b8hQ_hbJC4rwre9UYNIUI",
  authDomain:"mon421-a1108.firebaseapp.com",
  databaseURL:"https://mon421-a1108-default-rtdb.europe-west1.firebasedatabase.app",
  projectId:"mon421-a1108",
  storageBucket:"mon421-a1108.appspot.com",
  messagingSenderId:"354289081138",
  appId:"1:354289081138:web:be104504732e1ef984952b"
};
firebase.initializeApp(cfg);
const db = firebase.database();

/* ===== tiny DB adapters (string paths) ===== */
const SET    = (path, val)      => db.ref(path).set(val);
const UPDATE = (patches)        => db.ref().update(patches);
const TX     = (path, fn)       => db.ref(path).transaction(fn);
const GET    = (path)           => db.ref(path).get();
const ON     = (path, cb)       => db.ref(path).on('value', s => cb({exists:()=>s.exists(), val:()=>s.val()}));
const PUSH   = (path, val)      => db.ref(path).push(val);

/* ===== SAFE logger & toast ===== */
(() => {
  const logEl = document.querySelector('#dbgLog');
  const btnClear = document.querySelector('#dbgClear');
  const btnColl  = document.querySelector('#dbgCollapse');
  let collapsed=false, hasPanel=!!logEl;

  function addLine(level,...args){
    if(!hasPanel) return;
    const t=new Date().toISOString().split('T')[1].replace('Z','');
    const msg=args.map(a=>{try{return typeof a==='object'?JSON.stringify(a):String(a);}catch{return String(a);}}).join(' ');
    logEl.textContent += `[${t}] ${level.toUpperCase()}: ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  if(btnClear) btnClear.onclick=()=>{ if(hasPanel) logEl.textContent=''; };
  if(btnColl)  btnColl.onclick =()=>{ if(!hasPanel) return; collapsed=!collapsed; logEl.style.display=collapsed?'none':'block'; btnColl.textContent=collapsed?'Expand':'Collapse'; };

  const _c={...console};
  console.log  = (...a)=>{ addLine('log',...a);  _c.log(...a); };
  console.warn = (...a)=>{ addLine('warn',...a); _c.warn(...a); };
  console.error= (...a)=>{ addLine('error',...a);_c.error(...a); };
  window.addEventListener('error',e=>addLine('onerror',e.message));
  window.addEventListener('unhandledrejection',e=>addLine('promise', e.reason?.message||String(e.reason)));

  const toast = document.querySelector('#toast');
  window.notify = (msg) => {
    if (toast) { toast.textContent=msg; toast.style.display='block'; clearTimeout(window.notify._t); window.notify._t=setTimeout(()=>toast.style.display='none',3000); }
    _c.warn('TOAST', msg);
  };
})();

/* ===== DOM refs ===== */
const $=s=>document.querySelector(s);
const el={lobby:$('#lobby'),game:$('#game'),players:$('#players'),logCard:$('#logCard'),
displayName:$('#displayName'),roomInput:$('#roomInput'),startPoints:$('#startPoints'),
createBtn:$('#createBtn'),joinBtn:$('#joinBtn'),startBtn:$('#startBtn'),leaveBtn:$('#leaveBtn'),
roomCode:$('#roomCode'),interBanner:$('#interBanner'),currentPlayer:$('#currentPlayer'),rollsLeft:$('#rollsLeft'),
dice:$('#dice'),comboHint:$('#comboHint'),rollBtn:$('#rollBtn'),toggleAllBtn:$('#toggleAllBtn'),endTurnBtn:$('#endTurnBtn'),
log:$('#log'),overlay:$('#overlay'),winnerName:$('#winnerName'),replayBtn:$('#replayBtn')};

/* ===== client state ===== */
let roomId=localStorage.getItem('r421_roomId')||null;
let myId=localStorage.getItem('r421_myId')||(Math.random().toString(36).slice(2,10));
localStorage.setItem('r421_myId',myId);
let seat=localStorage.getItem('r421_seat'); seat=seat!==null?parseInt(seat,10):null;
let lastLogTs = 0; // for incremental log rendering
let isRolling = false;

/* ===== crypto RNG ===== */
function rand32(){ const a=new Uint32Array(1); crypto.getRandomValues(a); return a[0]; }
function d6(){ return (rand32()%6)+1; }
function randInt(min,max){ // inclusive
  const span=max-min+1; return min + (rand32()%span);
}

/* ===== rules ===== */
const sortAsc=a=>[...a].sort((x,y)=>x-y), sortDesc=a=>[...a].sort((x,y)=>y-x);
const is421=d=>{const s=sortDesc(d); return s[0]===4&&s[1]===2&&s[2]===1;};
const isBrelan=d=>{const s=sortDesc(d); return s[0]===s[1]&&s[1]===s[2];};
const is111=d=>{const s=sortDesc(d); return s[0]===1&&s[1]===1&&s[2]===1;};
const is11x=d=>{const s=sortDesc(d); return s[0]!==1 && ((s[0]===1&&s[1]===1)||(s[0]===1&&s[2]===1)||(s[1]===1&&s[2]===1));};
const xOfPair=d=>{const c={};d.forEach(v=>c[v]=(c[v]||0)+1);for(const k in c)if(c[k]===1)return +k;return null;};
const isSuite=d=>['123','234','345','456'].includes(sortAsc(d).join(''));
const isPaire=d=>new Set(d).size===2;

function rankHand(d){
  const s=sortDesc(d);
  if(is421(s)) return {order:7,score:1000,label:'421',category:'421',meta:{}};
  if(is111(s)) return {order:6,score:601,label:'1-1-1',category:'111',meta:{}};
  if(is11x(s)){ const x=xOfPair(s); return {order:5,score:500+x,label:`1-1-${x}`,category:'11x',meta:{x}}; }
  if(isBrelan(s)){ const x=s[0]; return {order:4,score:400+x,label:`${x}-${x}-${x}`,category:'Brelan',meta:{x}}; }
  if(isSuite(s)){ const map={'456':4,'345':3,'234':2,'123':1}; const key=sortAsc(s).join(''); return {order:3,score:300+map[key],label:key.split('').join('-'),category:'Suite',meta:{} }; }
  if(isPaire(s)){ let pair,k; if(s[0]===s[1]){pair=s[0];k=s[2];}else{pair=s[1];k=s[0];} return {order:2,score:200+pair*10+k,label:`${pair}-${pair}-${k}`,category:'Paire',meta:{pair,k}}; }
  const [a,b,c]=s; return {order:1,score:100+a*25+b*5+c,label:`${a}-${b}-${c}`,category:'Haute',meta:{}};
}
function winnerPoints(r){
  switch(r.category){
    case'421':return 8; case'111':return 7; case'11x':return r.meta?.x||0;
    case'Brelan':return r.meta?.x||0; case'Suite':return 2; case'Paire':return 1; case'Haute':return 1; default:return 0;
  }
}

/* ===== helpers ===== */
const seatKeys=room=>Object.keys(room.players||{}).map(k=>+k).filter(n=>!Number.isNaN(n)).sort((a,b)=>a-b);
const joinedSeats=room=>seatKeys(room).filter(i=>room.players[i]?.id);
function setMiniDice(container,dice){container.innerHTML='';(dice||[1,1,1]).forEach(v=>{const d=document.createElement('div');d.className='d';d.textContent=v;container.appendChild(d);});}
function safePath(p){if(!roomId)return{};const out={};for(const k in p)out[`rooms/${roomId}/${k}`]=p[k];return out;}
async function safeUpdate(p){if(!roomId)return;console.log('safeUpdate',p);await UPDATE(safePath(p));}
async function appendLog(msg){if(!roomId)return;try{await PUSH(`rooms/${roomId}/log`,{t:Date.now(),msg});console.log('LOG+',msg);}catch(e){console.error('log',e.message);}}

/* ===== Firebase HEALTHCHECK (runs once on load) ===== */
(async()=>{
  try{
    const key = Math.random().toString(36).slice(2,8);
    await SET(`__health/${key}`, {t:Date.now(), ok:true});
    const snap = await GET(`__health/${key}`);
    console.log('HEALTHCHECK ok?', snap.exists());
  }catch(e){
    notify('Firebase healthcheck failed: '+e.message);
    console.error('HEALTHCHECK', e);
  }
})();

/* ===== Lobby ===== */
async function createRoom(){
  try{
    el.createBtn.disabled = el.joinBtn.disabled = true;
    const code=($('#roomInput').value.trim()||Math.random().toString(36).slice(2,7)).toUpperCase();
    const exists = await GET('rooms/'+code); if(exists.exists()) return notify('Code d√©j√† utilis√©. Essaie un autre.');
    const startPts=Math.max(1,Math.min(99,parseInt($('#startPoints').value||'10',10)));
    const init={createdAt:Date.now(),started:false,locked:false,gameOver:false,startPoints:startPts,current:0,round:1,firstRollsLimit:null,players:{},log:{}};
    await SET('rooms/'+code,init);
    roomId=code; localStorage.setItem('r421_roomId',roomId);
    console.log('ROOM CREATED',code);
    await joinRoom(code);
  }catch(e){
    notify('Cr√©ation: '+e.message);
    console.error(e);
  }finally{
    el.createBtn.disabled = el.joinBtn.disabled = false;
  }
}
async function joinRoom(code){
  try{
    el.createBtn.disabled = el.joinBtn.disabled = true;
    code=(code||$('#roomInput').value.trim()).toUpperCase(); if(!code) return notify('Code manquant');
    const snap=await GET('rooms/'+code); if(!snap.exists()) return notify('Salle introuvable.');
    const room=snap.val();
    if(room.started&&room.locked){
      let ok=false; for(const s of seatKeys(room)) if(room.players[s]?.id===myId){ok=true;break;}
      if(!ok) return notify('Partie en cours ‚Äî rejoins avant le d√©marrage.');
    }
    seat=null; for(const s of seatKeys(room)){ if(room.players[s]?.id===myId){ seat=s; break; } }
    if(seat===null && !room.started){
      let seatIdx=0; while(room.players?.[seatIdx]) seatIdx++;
      const res=await TX(`rooms/${code}/players/${seatIdx}`, cur=>{
        if(!cur||!cur.id) return { id:myId, name:($('#displayName').value.trim()||'Joueur'), score:room.startPoints||10, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0, online:true, away:false };
        return cur;
      });
      if(res.committed && res.snapshot.val()?.id===myId){ seat=seatIdx; console.log('SEAT CLAIMED', seat); }
      if(seat!==null) await appendLog(`üü¢ ${($('#displayName').value.trim()||'Joueur')} a rejoint (J${seat+1})`);
      // presence marker
      try{
        db.ref(`rooms/${code}/players/${seat}`).onDisconnect().update({ online:false, away:true, lastSeen:Date.now() });
      }catch{}
    }
    roomId=code; localStorage.setItem('r421_roomId',roomId); if(seat!==null)localStorage.setItem('r421_seat',String(seat));
    el.lobby.style.display='none'; el.game.style.display='block'; el.players.style.display='grid'; el.logCard.style.display='block'; el.roomCode.textContent=code;
    console.log('JOINED ROOM',code,'SEAT',seat);
    subscribe();
  }catch(e){
    notify('Rejoindre: '+e.message);
    console.error(e);
  }finally{
    el.createBtn.disabled = el.joinBtn.disabled = false;
  }
}
async function releaseSeat(){
  try{
    if(!roomId||seat==null)return;
    const rs=await GET('rooms/'+roomId); if(!rs.exists())return;
    const room=rs.val();
    if(!room.started){
      const leaving=room.players?.[seat]?.name||'Joueur';
      await UPDATE({[`rooms/${roomId}/players/${seat}`]:null});
      await appendLog(`üö™ ${leaving} a quitt√© (J${seat+1})`);
    } else {
      await UPDATE({[`rooms/${roomId}/players/${seat}/away`]:true, [`rooms/${roomId}/players/${seat}/online`]:false, [`rooms/${roomId}/players/${seat}/lastSeen`]:Date.now()});
    }
  }catch(e){ console.error('releaseSeat', e); }
}

/* Buttons */
el.createBtn.addEventListener('click', ()=>{ try{ createRoom(); }catch(e){ notify('Erreur bouton Cr√©er'); } });
el.joinBtn  .addEventListener('click', ()=>{ try{ joinRoom($('#roomInput').value); }catch(e){ notify('Erreur bouton Rejoindre'); } });
el.leaveBtn .addEventListener('click', async ()=>{ try{ await releaseSeat(); }catch(e){} localStorage.removeItem('r421_roomId'); localStorage.removeItem('r421_seat'); location.reload(); });
el.toggleAllBtn.addEventListener('click', async ()=>{
  try{
    const rs=await GET('rooms/'+roomId); const room=rs.val(); const me=room.players[seat];
    if(!room.started||room.current!==seat||me.done||me.rollsLeft===3)return;
    const all = me.roll?.every(Boolean);
    await safeUpdate({[`players/${seat}/roll`]: [!all,!all,!all]});
  }catch(e){ notify('Erreur s√©lection'); }
});

/* ===== Live + watchdog ===== */
let lastRoom=null, watcher=null;
function subscribe(){
  if(watcher) clearInterval(watcher);
  ON('rooms/'+roomId, snap=>{ if(!snap.exists())return; lastRoom=snap.val(); render(lastRoom); });
  watcher=setInterval(async()=>{
    if(!lastRoom||!lastRoom.started||lastRoom.gameOver||lastRoom.settling)return;
    const seats=joinedSeats(lastRoom);
    if(seats.length>=2 && seats.every(i=>lastRoom.players[i].done)){
      console.log('WATCHDOG settle'); await settleTransaction();
    }
  },1000);
}

/* ===== Render ===== */
function renderPlayers(room){
  const cont=el.players; cont.innerHTML='';
  seatKeys(room).forEach(i=>{
    const p=room.players[i]||{};
    const card=document.createElement('div');
    card.className='card player'+(room.started&&room.current===i&&p.id&&!p.done?' active':'');
    card.innerHTML=`<div class="pill">J${i+1}</div><h2>${p.id?(p.name||('Joueur '+(i+1))):'‚Äî (vide)'}</h2>
      <div class="small"><span>${p.score??'‚Äî'}</span> pts</div>
      <div class="small">${p.lastRank?(p.lastRank.label+' ('+p.lastRank.category+')'):'‚Äî'}</div>
      <div class="mini" id="m${i}"></div>`;
    cont.appendChild(card);
    setMiniDice(card.querySelector('#m'+i), p.dice);
  });
}
function render(room){
  // append-only log
  const entries=room.log?Object.values(room.log).sort((a,b)=>a.t-b.t):[];
  const newOnes = entries.filter(e=>e.t>lastLogTs);
  if(newOnes.length){
    newOnes.forEach(e=>{const p=document.createElement('p');p.textContent=e.msg;el.log.appendChild(p);});
    lastLogTs = newOnes[newOnes.length-1].t;
    el.log.scrollTop = el.log.scrollHeight;
  }

  renderPlayers(room);
  const seats=joinedSeats(room);
  el.startBtn.disabled=room.started||seats.length<2;
  el.interBanner.textContent=room.started?'':`Joueurs pr√™ts: ${seats.length} (min 2)`;
  const me=(seat!=null&&room.players[seat])?room.players[seat]:null;
  const myTurn=!!(me&&room.started&&room.current===seat&&!me.done);
  el.currentPlayer.textContent=room.players[room.current]?.name||'‚Äî';
  el.rollsLeft.textContent=me?(me.rollsLeft??'‚Äî'):'‚Äî';

  // dice UI
  el.dice.innerHTML='';
  const dice=me?(me.dice||[1,1,1]):[1,1,1];
  const firstRoll=me?(me.rollsLeft===3):false;
  dice.forEach((v,i)=>{
    const b=document.createElement('button');
    b.className='die'+((me&&me.roll&&me.roll[i])?' roll':'');
    b.innerHTML=`<span>${v}</span><small>${(me&&me.roll&&me.roll[i])?'√† relancer':'gard√©'}</small>`;
    b.onclick=()=>{ if(firstRoll||!myTurn||isRolling) return; toggleRoll(i); };
    el.dice.appendChild(b);
  });
  if(firstRoll&&me&&!(me.roll && me.roll.every(Boolean))) safeUpdate({[`players/${seat}/roll`]:[true,true,true]});

  const limit=room.firstRollsLimit; const used=me?(3-me.rollsLeft):0; const overLimit=(limit!=null&&used>=limit);
  el.toggleAllBtn.disabled=(!myTurn||firstRoll||isRolling);
  el.rollBtn.disabled=(!myTurn||me?.done||overLimit||(me&&me.rollsLeft<=0)||isRolling);
  el.endTurnBtn.disabled=(!myTurn||me?.done||isRolling);
  if(room.gameOver){
    el.overlay.style.display='flex';
    const w=room.winnerSeat!=null?(room.players[room.winnerSeat]?.name||'‚Äî'):'‚Äî';
    el.winnerName.textContent=w;
  } else el.overlay.style.display='none';
}

/* ===== Actions ===== */
async function toggleRoll(i){
  const rs=await GET('rooms/'+roomId); const room=rs.val(); const me=room.players[seat];
  if(!room.started||room.current!==seat||me.done)return;
  if(me.rollsLeft===3)return;
  const roll=me.roll.slice(); roll[i]=!roll[i];
  await safeUpdate({[`players/${seat}/roll`]:roll});
  console.log('TOGGLE ROLL',i,roll);
}
async function startGame(){
  const rs=await GET('rooms/'+roomId); const room=rs.val();
  const seats=joinedSeats(room); if(seats.length<2)return notify('Il faut au moins 2 joueurs.');
  const upd={}; seats.forEach(i=>{const p=room.players[i]; upd['players/'+i]={...p,dice:[1,1,1],roll:[true,true,true],rollsLeft:3,done:false,lastRank:null,rollsUsed:0,away:false,online:true};});
  upd.current=seats[0]; upd.round=1; upd.started=true; upd.locked=true; upd.gameOver=false; upd.firstRollsLimit=null; upd.settling=false;
  await safeUpdate(upd); await appendLog(`üöÄ Partie d√©marr√©e (joueurs: ${seats.length})`);
}
el.startBtn.addEventListener('click',()=>{ try{ startGame(); }catch(e){ notify('Erreur d√©marrage'); } });

async function rollSelected(){
  const rs=await GET('rooms/'+roomId); const room=rs.val(); const me=room.players[seat];
  if(!room.started||room.current!==seat||me.done||me.rollsLeft<=0||isRolling)return;
  const limit=room.firstRollsLimit; const used=3-me.rollsLeft; if(limit!=null&&used>=limit)return;

  isRolling = true; document.body.classList.add('rolling'); render(room);

  const dice=me.dice.slice();
  const toRoll=me.roll.map((x,idx)=>x?idx:null).filter(x=>x!==null);
  const final={}; toRoll.forEach(i=>final[i]=d6());

  for(const i of toRoll){
    const steps=10+randInt(0,5);
    for(let t=0;t<steps;t++){
      dice[i]=d6();
      const btn=el.dice.children[i]; if(btn) btn.querySelector('span').textContent=dice[i];
      await new Promise(r=>setTimeout(r,40));
    }
    dice[i]=final[i]; const btn=el.dice.children[i]; if(btn) btn.querySelector('span').textContent=dice[i];
    await new Promise(r=>setTimeout(r,100));
  }

  const r=rankHand(dice);
  await safeUpdate({[`players/${seat}/dice`]:dice,[`players/${seat}/lastRank`]:r,[`players/${seat}/rollsLeft`]:me.rollsLeft-1,[`players/${seat}/rollsUsed`]:(me.rollsUsed||0)+1});

  isRolling = false; document.body.classList.remove('rolling');
}
el.rollBtn.addEventListener('click',()=>{ try{ rollSelected(); }catch(e){ notify('Erreur lancer'); } });

async function endTurn(){
  const rs=await GET('rooms/'+roomId); let room=rs.val(); const me=room.players[seat];
  if(!room.started||room.current!==seat||me.done||isRolling)return;
  if(me.rollsLeft===3)await rollSelected();
  const me2=(await GET(`rooms/${roomId}/players/${seat}`)).val();
  if(!me2.lastRank){const r=rankHand(me2.dice); await safeUpdate({[`players/${seat}/lastRank`]:r});}
  await safeUpdate({[`players/${seat}/done`]:true,[`players/${seat}/roll`]:[false,false,false]});
  const used=me2.rollsUsed||(3-me2.rollsLeft);
  if(room.firstRollsLimit==null){await safeUpdate({firstRollsLimit:used}); await appendLog(`üéØ Limite de lancers ce tour: ${used} (par ${me2.name||'Joueur'})`);}
  room=(await GET('rooms/'+roomId)).val();
  const seats=joinedSeats(room); const remaining=seats.filter(i=>!room.players[i].done);
  if(remaining.length>0){
    const idx=seats.indexOf(room.current); let next=room.current;
    for(let k=1;k<=seats.length;k++){const cand=seats[(idx+k)%seats.length]; if(!room.players[cand].done){next=cand;break;}}
    await safeUpdate({current:next}); await appendLog(`‚è≠Ô∏è Tour √† ${room.players[next]?.name||('J'+(next+1))}`);
  }else{
    await settleTransaction();
  }
}
el.endTurnBtn.addEventListener('click',()=>{ try{ endTurn(); }catch(e){ notify('Erreur fin de tour'); } });

async function settleTransaction(){
  // single-flight using TX on the whole room and a 'settling' gate
  const res = await TX('rooms/'+roomId,(room)=>{
    if(!room) return room;
    if(room.settling) return room;  // someone else is settling
    const seats=joinedSeats(room); if(seats.length<2) return room;
    room.settling = true;

    const rankOf=i=>(room.players[i].lastRank||rankHand(room.players[i].dice));
    const ranked=seats.map(i=>({i,r:rankOf(i)})).sort((a,b)=> (b.r.order-a.r.order) || (b.r.score-a.r.score));
    const top=ranked[0].r; const bot=ranked[ranked.length-1].r;
    const bestSeat=ranked[0].i, worstSeat=ranked[ranked.length-1].i;

    const amount=winnerPoints(top);
    if(amount>0&&bestSeat!=null&&worstSeat!=null){
      const before=room.players[bestSeat].score|0;
      const paid=Math.min(before,amount); // best hand pays
      room.players[bestSeat].score=before-paid;
      room.players[worstSeat].score=(room.players[worstSeat].score||0)+paid;
      room.lastTransfer={payer:bestSeat,payee:worstSeat,amount:paid,combo:top.label};
    }

    let winnerSeat=null; for(const i of seats) if((room.players[i].score|0)===0){winnerSeat=i;break;}
    if(winnerSeat!=null){
      room.started=false; room.gameOver=true; room.winnerSeat=winnerSeat; room.lastSettle=Date.now(); room.settling=false;
      return room;
    }
    // next round: worst starts
    room.round=(room.round||1)+1; room.current=worstSeat; room.firstRollsLimit=null;
    seats.forEach(i=>{const p=room.players[i]; room.players[i]={...p,dice:[1,1,1],roll:[true,true,true],rollsLeft:3,done:false,lastRank:null,rollsUsed:0};});
    room.lastSettle=Date.now(); room.settling=false;
    return room;
  });

  // only the committing client logs transfer
  const rs=await GET('rooms/'+roomId); const room=rs.val();
  if(res.committed && room.lastTransfer){
    const p=room.players[room.lastTransfer.payer]?.name||'Joueur';
    const q=room.players[room.lastTransfer.payee]?.name||'Joueur';
    await appendLog(`‚úÖ ${p} paie ${room.lastTransfer.amount} ‚Üí ${q} (${room.lastTransfer.combo})`);
    await safeUpdate({lastTransfer:null});
  }
}
el.replayBtn.addEventListener('click',async()=>{
  const rs=await GET('rooms/'+roomId); const room=rs.val(); const seats=joinedSeats(room); const upd={};
  seats.forEach(i=>{const base=room.startPoints||10; const p=room.players[i]; upd['players/'+i]={...p,score:base,dice:[1,1,1],roll:[true,true,true],rollsLeft:3,done:false,lastRank:null,rollsUsed:0,away:false,online:true};});
  upd.gameOver=false; upd.winnerSeat=null; upd.started=false; upd.firstRollsLimit=null; upd.settling=false;
  await safeUpdate(upd);
});
</script>
</body>
</html>

If you want server-side dice and validation next, say so. That is the real cheat fix.

