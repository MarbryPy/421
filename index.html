<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>421 â€“ Multi (Firebase)</title>
<style>
  :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --fg:#e5e7eb; --accent:#22d3ee; --btn:#1f2937; --warn:#f59e0b; --bad:#ef4444; }
  * { box-sizing: border-box; } body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; gap:12px; }
  h1 { margin:0; font-size:18px; letter-spacing:.3px; }
  main { max-width:980px; margin:0 auto; padding:20px; display:grid; gap:16px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  .card { background:var(--panel); border:1px solid #1f2937; border-radius:14px; padding:14px; }
  .card h2 { margin:0 0 8px 0; font-size:15px; color:var(--accent); }
  .muted { color:var(--muted); }
  input { background:#0b1220; color:#e5e7eb; border:1px solid #1f2937; border-radius:10px; padding:10px 12px; }
  button { appearance:none; border:1px solid #283548; background:var(--btn); color:var(--fg); padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
  button.primary { border-color:#164e63; background:#0e749022; }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .players { display:grid; grid-template-columns: repeat(3,1fr); gap:12px; } @media (max-width:720px){ .players{grid-template-columns:1fr;} }
  .player { position:relative; transition: box-shadow .2s ease; }
  .player.active { outline:2px solid var(--accent); outline-offset:2px; box-shadow:0 0 0 0 rgba(34,211,238,.6); animation:pulse 1.6s infinite; }
  @keyframes pulse { 0%{ box-shadow:0 0 0 0 rgba(34,211,238,.6);} 70%{ box-shadow:0 0 0 12px rgba(34,211,238,0);} 100%{ box-shadow:0 0 0 0 rgba(34,211,238,0);} }
  .pill { position:absolute; top:10px; right:10px; font-size:12px; color:#0e7490; background:#0e749022; border:1px solid #0e749022; padding:2px 8px; border-radius:999px; }
  .dice { display:flex; gap:10px; } .die { width:70px; height:70px; border-radius:10px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; position:relative; }
  .die span { font-size:28px; font-weight:800; } .die small { position:absolute; bottom:6px; left:6px; font-size:10px; color:var(--muted); }
  .die.roll { outline:2px solid var(--warn); outline-offset:2px; }
  .mini { display:flex; gap:4px; margin-top:6px; }
  .mini .d { width:18px; height:18px; border-radius:4px; background:#0b1220; border:1px solid #263245; display:grid; place-items:center; font-size:11px; }
  .log { max-height:260px; overflow:auto; border-radius:10px; background:#0b1220; border:1px solid #1f2937; padding:10px; font-size:13px; }
  .log p { margin:0 0 8px 0; }
  .overlay { position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; padding:20px; }
  .dialog { background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:18px; max-width:420px; width:90%; text-align:center; }
</style>
</head>
<body>
<header>
  <h1>ðŸŽ² 421 â€“ Multi (Firebase)</h1>
  <div class="small">Aucun compte requis</div>
</header>

<main>
  <section id="lobby" class="card">
    <h2>CrÃ©er / Rejoindre la salle</h2>
    <div class="row">
      <input id="displayName" placeholder="Ton pseudo" />
      <input id="roomInput" placeholder="Code (ex: 5L9QK)" />
      <input id="startPoints" type="number" min="1" max="99" value="10" style="width:90px" title="Points de dÃ©part"/>
      <button id="createBtn" class="primary">CrÃ©er</button>
      <button id="joinBtn">Rejoindre</button>
    </div>
    <div class="small">Le crÃ©ateur dÃ©marre quand tout le monde est lÃ  (2 ou 3 joueurs).</div>
  </section>

  <section id="game" class="card" style="display:none;">
    <h2>Partie</h2>
    <div class="row" style="justify-content:space-between; align-items:start;">
      <div>
        <div class="muted">Salle</div>
        <div id="roomCode" class="small">â€”</div>
        <div id="interBanner" class="small" style="margin-top:6px;"></div>
        <div class="muted" style="margin-top:6px;">Joueur actuel</div>
        <div id="currentPlayer" style="font-size:22px;font-weight:800;">â€”</div>
        <div class="muted" style="margin-top:6px;">Lancers restants : <span id="rollsLeft">â€”</span></div>
      </div>
      <div>
        <div class="muted">Ta main</div>
        <div id="dice" class="dice"></div>
        <div id="comboHint" class="small">â€”</div>
      </div>
      <div class="row" style="flex-direction:column; min-width:220px;">
        <button id="rollBtn" class="primary">Relancer (sÃ©lectionnÃ©s)</button>
        <button id="toggleAllBtn">Tout sÃ©lectionner / dÃ©sÃ©lectionner</button>
        <button id="endTurnBtn">Terminer mon tour</button>
        <button id="startBtn" class="primary">DÃ©marrer la partie</button>
        <button id="leaveBtn">Quitter</button>
      </div>
    </div>
  </section>

  <section id="players" class="players" style="display:none;">
    <div class="card player" id="p0"><div class="pill">J1</div><h2 id="n0">â€”</h2><div class="small"><span id="s0">â€”</span> pts</div><div class="small" id="r0">â€”</div><div class="mini" id="m0"></div></div>
    <div class="card player" id="p1"><div class="pill">J2</div><h2 id="n1">â€”</h2><div class="small"><span id="s1">â€”</span> pts</div><div class="small" id="r1">â€”</div><div class="mini" id="m1"></div></div>
    <div class="card player" id="p2"><div class="pill">J3</div><h2 id="n2">â€”</h2><div class="small"><span id="s2">â€”</span> pts</div><div class="small" id="r2">â€”</div><div class="mini" id="m2"></div></div>
  </section>

  <section id="logCard" class="card" style="display:none;">
    <h2>Historique</h2>
    <div id="log" class="log"></div>
  </section>
</main>

<div id="overlay" class="overlay">
  <div class="dialog">
    <div style="font-size:22px; font-weight:800;">ðŸŽ‰ Vainqueur</div>
    <div id="winnerName" style="margin:8px 0 12px;">â€”</div>
    <button id="replayBtn" class="primary">Rejouer (mÃªmes joueurs)</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getDatabase, ref, onValue, set, update, get, runTransaction, push } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

  const cfg = {"apiKey": "AIzaSyB9QKf88f8YS3b8hQ_hbJC4rwre9UYNIUI", "authDomain": "mon421-a1108.firebaseapp.com", "databaseURL": "https://mon421-a1108-default-rtdb.europe-west1.firebasedatabase.app", "projectId": "mon421-a1108", "storageBucket": "mon421-a1108.appspot.com", "messagingSenderId": "354289081138", "appId": "1:354289081138:web:be104504732e1ef984952b"};
  const app = initializeApp(cfg);
  const db = getDatabase(app);
  const $ = s => document.querySelector(s);
  /* === DOM cache (added) === */
  const el = {
    lobby: $('#lobby'), game: $('#game'), players: $('#players'), logCard: $('#logCard'),
    displayName: $('#displayName'), roomInput: $('#roomInput'), startPoints: $('#startPoints'),
    createBtn: $('#createBtn'), joinBtn: $('#joinBtn'), startBtn: $('#startBtn'), leaveBtn: $('#leaveBtn'),
    roomCode: $('#roomCode'), interBanner: $('#interBanner'),
    currentPlayer: $('#currentPlayer'), rollsLeft: $('#rollsLeft'),
    dice: $('#dice'), comboHint: $('#comboHint'),
    rollBtn: $('#rollBtn'), toggleAllBtn: $('#toggleAllBtn'), endTurnBtn: $('#endTurnBtn'),
    n0: $('#n0'), n1: $('#n1'), n2: $('#n2'),
    s0: $('#s0'), s1: $('#s1'), s2: $('#s2'),
    r0: $('#r0'), r1: $('#r1'), r2: $('#r2'),
    m0: $('#m0'), m1: $('#m1'), m2: $('#m2'),
    log: $('#log')
  };

  
  let roomId = localStorage.getItem('r421_roomId') || null;
  let myId   = localStorage.getItem('r421_myId') || (Math.random().toString(36).slice(2,10));
  localStorage.setItem('r421_myId', myId);
  let seat   = localStorage.getItem('r421_seat');
  if (seat !== null) seat = parseInt(seat,10); else seat = null;

  function safePath(patches) {
    if (!roomId) return null;
    const out = {};
    for (const k in patches) out[`rooms/${roomId}/${k}`] = patches[k];
    return out;
  }
  async function safeUpdate(patches) {
    if (!roomId) return;
    await update(ref(db), safePath(patches));
  }
  async function appendLog(msg){
    if (!roomId) return;
    try { await push(ref(db, `rooms/${roomId}/log`), { t: Date.now(), msg }); } catch(e){}
  }

  // ---- Sounds (minimal)
  const AC = window.AudioContext||window.webkitAudioContext; const ctx = new AC();
  function tone(f,d=0.12,t='sine',v=0.05){const o=ctx.createOscillator(),g=ctx.createGain();o.type=t;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(ctx.destination);o.start();setTimeout(()=>o.stop(),d*1000);}
  function yourTurnSound(){ tone(880); setTimeout(()=>tone(1175),120); }

  // ---- Rules
  const sortAsc=a=>[...a].sort((x,y)=>x-y), sortDesc=a=>[...a].sort((x,y)=>y-x);
  const is421 = d => (sortDesc(d)[0]===4 && sortDesc(d)[1]===2 && sortDesc(d)[2]===1);
  const isBrelan = d => d[0]===d[1] && d[1]===d[2];
  const is111 = d => d[0]===1 && d[1]===1 && d[2]===1;
  const is11x = d => sortDesc(d)[0]!==1 && ((d[0]===1 && d[1]===1) || (d[0]===1 && d[2]===1) || (d[1]===1 && d[2]===1));
  const xOfPair = d => { const c={}; d.forEach(v=>c[v]=(c[v]||0)+1); for(const k in c) if(c[k]===1) return parseInt(k,10); return null; };
  const isSuite = d => ['123','234','345','456'].includes(sortAsc(d).join(''));
  const isPaire = d => new Set(d).size===2;
  function rankHand(d){
    const s=sortDesc(d);
    if(is421(s)) return {order:7, label:'421', category:'421', meta:{}};
    if(is111(s)) return {order:6, label:'1â€‘1â€‘1', category:'111', meta:{}};
    if(is11x(s)) return {order:5, label:`1â€‘1â€‘${xOfPair(s)}`, category:'11x', meta:{x:xOfPair(s)}};
    if(isBrelan(s)) return {order:4, label:`${s[0]}â€‘${s[0]}â€‘${s[0]}`, category:'Brelan', meta:{x:s[0]}};
    if(isSuite(s)) return {order:3, label:sortAsc(s).join('â€‘'), category:'Suite', meta:{}};
    if(isPaire(s)) { let pair,k; if(s[0]===s[1]){pair=s[0];k=s[2];} else {pair=s[1];k=s[0];} return {order:2, label:`${pair}â€‘${pair}â€‘${k}`, category:'Paire', meta:{pair,k}}; }
    return {order:1, label:`${s[0]}â€‘${s[1]}â€‘${s[2]}`, category:'Haute', meta:{}};
  }
  function winnerPoints(rank){
    switch(rank.category){
      case '421': return 8;
      case '111': return 7;
      case '11x': return rank.meta?.x || 0;
      case 'Brelan': return rank.meta?.x || 0;
      case 'Suite': return 2;
      case 'Paire': return 1;
      case 'Haute': return 1;
      default: return 0;
    }
  }
  function cmp(a,b){ return (a.order===b.order)?0:(a.order>b.order?1:-1); }
  const rDie=()=>1+Math.floor(Math.random()*6);

  function setMiniDice(container, dice){ container.innerHTML=''; (dice||[1,1,1]).forEach(v=>{ const d=document.createElement('div'); d.className='d'; d.textContent=v; container.appendChild(d); }); }

  // ---- Lobby actions
  async function createRoom(){
    const code=($('#roomInput').value.trim()||Math.random().toString(36).slice(2,7)).toUpperCase();
    const startPts = Math.max(1, Math.min(99, parseInt($('#startPoints').value||'10',10)));
    const seatInit = (pts)=>({ id:'', name:'â€”', score:pts, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 });
    const init={ createdAt:Date.now(), started:false, locked:false, gameOver:false, startPoints:startPts,
      current:0, round:1, firstRollsLimit:null, players:{"0":seatInit(startPts),"1":seatInit(startPts),"2":seatInit(startPts)}, log:[] };
    await set(ref(db,'rooms/'+code), init);
    roomId=code; localStorage.setItem('r421_roomId', roomId);
    await joinRoom(code);
  }
  async function joinRoom(code){
    code=(code||$('#roomInput').value.trim()).toUpperCase();
    if(!code) return alert('Code manquant');
    const snap=await get(ref(db,'rooms/'+code));
    if(!snap.exists()) return alert('Salle introuvable.');
    const room=snap.val();
    // lock: no new joins after start
    if(room.started && room.locked && ![0,1,2].some(i=>room.players[i].id===myId)) return alert('Partie en cours â€” rejoins avant le dÃ©marrage.');

    // reclaim seat
    seat=null;
    for(const s of [0,1,2]){ const p=room.players[s]; if(p.id===myId){ seat=s; break; } }
    // claim empty seat if not started
    if(seat===null && !room.started){
      for(const s of [0,1,2]){ 
        const res = await runTransaction(ref(db,`rooms/${code}/players/${s}`),(cur)=>{
          if(!cur || !cur.id) return { id: myId, name: ($('#displayName').value.trim()||'Joueur'), score: room.startPoints||10, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 };
          return cur;
        });
        if(res.committed && res.snapshot.val().id===myId){ seat=s; break; }
      }
      if(seat!==null) await push(ref(db, `rooms/${code}/log`), { t: Date.now(), msg:`ðŸŸ¢ ${($('#displayName').value.trim()||'Joueur')} a rejoint (J${seat+1})` });
    }
    roomId=code; localStorage.setItem('r421_roomId', roomId);
    if(seat!==null) localStorage.setItem('r421_seat', String(seat));
    $('#lobby').style.display='none'; $('#game').style.display='block'; $('#players').style.display='grid'; $('#logCard').style.display='block'; $('#roomCode').textContent=code;
    subscribe();
  }

  document.getElementById('createBtn').addEventListener('click', async () => {
  try { await createRoom(); }
  catch (e) { alert('Erreur crÃ©ation: ' + (e && e.message || e)); console.error(e); }});

  document.getElementById('joinBtn').addEventListener('click', async () => {
  try { await joinRoom($('#roomInput').value); }
  catch (e) { alert('Erreur rejoindre: ' + (e && e.message || e)); console.error(e); }});
  
  document.getElementById('leaveBtn').addEventListener('click', ()=>location.reload());

  // ---- Live subscription
  function subscribe(){ onValue(ref(db,'rooms/'+roomId), (snap)=>{ if(!snap.exists()) return; render(snap.val()); }); }

  function render(room){
    // log list
    el.log.innerHTML='';
    const entries = room.log ? Object.values(room.log).sort((a,b)=>a.t-b.t) : [];
    entries.forEach(e=>{ const p=document.createElement('p'); p.textContent=e.msg; el.log.appendChild(p); });

    // players
    [0,1,2].forEach(i=>{
      const p=room.players[i];
      el['n'+i].textContent = p.id ? (p.name||('Joueur '+(i+1))) : 'â€” (vide)';
      el['s'+i].textContent = p.score ?? 'â€”';
      el['r'+i].textContent = p.lastRank ? (p.lastRank.label+' ('+p.lastRank.category+')') : 'â€”';
      document.getElementById('p'+i).classList.toggle('active', room.started && room.current===i && p.id && !p.done);
      setMiniDice(el['m'+i], p.dice);
    });

    const joined = [0,1,2].filter(i=>room.players[i].id);
    el.startBtn.disabled = room.started || joined.length < 2;
    el.interBanner.textContent = room.started ? '' : `Joueurs prÃªts: ${joined.length}/3 (min 2)`;

    const me = (seat!=null) ? room.players[seat] : null;
    const myTurn = !!(me && room.started && room.current===seat && !me.done);
    el.currentPlayer.textContent = room.players[room.current]?.name || 'â€”';
    el.rollsLeft.textContent = me ? (me.rollsLeft ?? 'â€”') : 'â€”';

    // dice UI
    el.dice.innerHTML='';
    const dice = me ? (me.dice||[1,1,1]) : [1,1,1];
    const firstRoll = me ? (me.rollsLeft===3) : false;
    dice.forEach((v,i)=>{
      const b=document.createElement('button');
      b.className='die'+((me && me.roll && me.roll[i])?' roll':'');
      b.innerHTML=`<span>${v}</span><small>${(me && me.roll && me.roll[i])?'Ã  relancer':'gardÃ©'}</small>`;
      b.onclick=()=>{ if(firstRoll) return; toggleRoll(i); };
      el.dice.appendChild(b);
    });
    if(firstRoll && me) safeUpdate({ ['players/'+seat+'/roll']:[true,true,true] });

    // roll limit enforcement
    const limit = room.firstRollsLimit;
    const disableRoll = !myTurn || (me && me.rollsLeft<=0) || (limit!=null && (3-me.rollsLeft) >= limit);
    el.toggleAllBtn.disabled = firstRoll || !myTurn;
    el.rollBtn.disabled = disableRoll;
    el.endTurnBtn.disabled = !myTurn;

    if(myTurn) try{ yourTurnSound(); }catch(e){}
  }

  async function toggleRoll(i){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done) return;
    if(me.rollsLeft===3) return;
    const roll=me.roll.slice(); roll[i]=!roll[i];
    await safeUpdate({ ['players/'+seat+'/roll']: roll });
  }

  async function startGame(){
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    const joined=[0,1,2].filter(i=>room.players[i].id);
    if(joined.length<2) return alert('Il faut au moins 2 joueurs.');
    const updates={};
    joined.forEach(i=>{
      const p=room.players[i];
      updates['players/'+i] = { ...p, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 };
    });
    updates['current'] = joined[0]; // initial starter = first joined
    updates['round'] = 1;
    updates['started'] = true;
    updates['locked'] = true;
    updates['gameOver'] = false;
    updates['firstRollsLimit'] = null;
    await safeUpdate(updates);
    await appendLog(`ðŸš€ Partie dÃ©marrÃ©e (joueurs: ${joined.length})`);
  }
  document.getElementById('startBtn').addEventListener('click', startGame);

  async function rollSelected(){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done || me.rollsLeft<=0) return;
    // enforce round limit
    const limit = room.firstRollsLimit;
    const used = 3 - me.rollsLeft;
    if (limit!=null && used >= limit) return; // hard stop
    // animate sequentially (local) then commit
    const dice=me.dice.slice();
    const toRoll=me.roll.map((x,idx)=>x?idx:null).filter(x=>x!==null);
    const final={}; toRoll.forEach(i=>final[i]= (1+Math.floor(Math.random()*6)));
    for(const i of toRoll){
      const steps = 10 + Math.floor(Math.random()*6);
      for(let t=0;t<steps;t++){ dice[i] = 1+Math.floor(Math.random()*6); const btn = el.dice.children[i]; if(btn) btn.querySelector('span').textContent = dice[i]; await new Promise(r=>setTimeout(r, 40)); }
      dice[i] = final[i]; const btn = el.dice.children[i]; if(btn) btn.querySelector('span').textContent = dice[i]; await new Promise(r=>setTimeout(r, 100));
    }
    const r=rankHand(dice);
    await safeUpdate({
      ['players/'+seat+'/dice']:dice,
      ['players/'+seat+'/lastRank']:r,
      ['players/'+seat+'/rollsLeft']:me.rollsLeft-1,
      ['players/'+seat+'/rollsUsed']:(me.rollsUsed||0)+1
    });
  }
  document.getElementById('rollBtn').addEventListener('click', rollSelected);

  async function endTurn(){
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); let room=rs.val(); const me=room.players[seat];
    if(!room.started || room.current!==seat || me.done) return;
    if(me.rollsLeft===3) await rollSelected();
    const me2 = (await get(ref(db,'rooms/'+roomId+'/players/'+seat))).val();
    if(!me2.lastRank){ const r=rankHand(me2.dice); await safeUpdate({ ['players/'+seat+'/lastRank']: r }); }
    await safeUpdate({ ['players/'+seat+'/done']:true, ['players/'+seat+'/roll']:[false,false,false] });
    // if first player ends, set round roll limit and log it
    const used = me2.rollsUsed || (3 - me2.rollsLeft);
    const limit = room.firstRollsLimit;
    if(limit==null){ await safeUpdate({ firstRollsLimit: used }); await appendLog(`ðŸŽ¯ Limite de lancers ce tour: ${used} (par ${me2.name||'Joueur'})`); }
    // advance or settle
    room = (await get(ref(db,'rooms/'+roomId))).val();
    const joined=[0,1,2].filter(i=>room.players[i].id);
    const remaining = joined.filter(i=>!room.players[i].done);
    if(remaining.length>0){
      // next among joined
      const idx = joined.indexOf(room.current); let next = room.current;
      for(let k=0;k<joined.length;k++){ next = joined[(idx+1+k)%joined.length]; if(!room.players[next].done) break; }
      await safeUpdate({ current: next });
    } else {
      await settleTransaction();
    }
  }
  document.getElementById('endTurnBtn').addEventListener('click', endTurn);

  async function settleTransaction(){
    if (!roomId) return;
    await runTransaction(ref(db,'rooms/'+roomId), (room)=>{
      if(!room) return room;
      const joined=[0,1,2].filter(i=>room.players[i] && room.players[i].id);
      if(joined.length<2) return room;
      // rank
      const ranked=joined.map(i=>({i, r:(room.players[i].lastRank || rankHand(room.players[i].dice))})).sort((a,b)=>((a.r.order===b.r.order)?0:(a.r.order>b.r.order?1:-1))).reverse();
      const bestSeats = ranked.filter(x=>(((x.r.order===ranked[0].r.order)?0:((x.r.order>ranked[0].r.order)?1:-1)))===0).map(x=>x.i);
      const worstSeats = ranked.filter(x=>(((x.r.order===ranked[ranked.length-1].r.order)?0:((x.r.order>ranked[ranked.length-1].r.order)?1:-1)))===0).map(x=>x.i);
      const bestSeat = bestSeats[0];
      const worstSeat = worstSeats[0];
      const winnerRank = room.players[bestSeat].lastRank || rankHand(room.players[bestSeat].dice);
      const amount = (function(rank){ switch(rank.category){ case '421': return 8; case '111': return 7; case '11x': return rank.meta?.x||0; case 'Brelan': return rank.meta?.x||0; case 'Suite': return 2; case 'Paire': return 1; case 'Haute': return 1; default: return 0; } })(winnerRank);
      if(amount>0 && bestSeat!=null && worstSeat!=null){
        const before = room.players[bestSeat].score;
        const paid = Math.min(before, amount);
        room.players[bestSeat].score = before - paid;
        room.players[worstSeat].score = (room.players[worstSeat].score||0) + paid;
        room.lastTransfer = { payer: bestSeat, payee: worstSeat, amount: paid, combo: winnerRank.label };
      }
      // win condition
      let winnerSeat=null;
      for(const i of joined) if(room.players[i].score===0) { winnerSeat=i; break; }
      if(winnerSeat!=null){
        room.started=false; room.gameOver=true; room.winnerSeat=winnerSeat;
        return room;
      }
      // next round: loser starts
      const nextStarter = worstSeats[0];
      room.round = (room.round||1)+1;
      room.current = nextStarter;
      room.firstRollsLimit = null;
      joined.forEach(i=>{ const p=room.players[i]; room.players[i] = { ...p, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0 }; });
      return room;
    });
    // append transfer log
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    if(room.lastTransfer){
      const p=room.players[room.lastTransfer.payer]?.name||'Joueur';
      const q=room.players[room.lastTransfer.payee]?.name||'Joueur';
      await appendLog(`âœ… ${p} paie ${room.lastTransfer.amount} â†’ ${q} (${room.lastTransfer.combo})`);
      await safeUpdate({ lastTransfer: null });
    }
  }

  document.getElementById('replayBtn').addEventListener('click', async ()=>{
    if (!roomId) return;
    const rs=await get(ref(db,'rooms/'+roomId)); const room=rs.val();
    const joined=[0,1,2].filter(i=>room.players[i].id);
    const upd={};
    joined.forEach(i=>{ const base=room.startPoints||10; const p=room.players[i]; upd['players/'+i]={...p, score:base, dice:[1,1,1], roll:[true,true,true], rollsLeft:3, done:false, lastRank:null, rollsUsed:0}; });
    upd['gameOver']=false; upd['winnerSeat']=null; upd['started']=false; upd['firstRollsLimit']=null;
    await safeUpdate(upd);
  });
</script>
</body>
</html>
